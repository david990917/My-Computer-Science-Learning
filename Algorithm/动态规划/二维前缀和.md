# 二维前缀和

二维前缀和可以应用在**二维数组元素和**计算中。

### 代码模板

1. 首先处理原来的数组，生成二位前缀和数组

```python
m,n=len(mat),len(mat[0])
P=[[0 for i in range(n+1)] for j in range(m+1)]
for i in range(1,m+1):
    for j in range(1,n+1):
        P[i][j]=P[i-1][j]+P[i][j-1]+mat[i-1][j-1]-P[i-1][j-1]
```

2. 定义**计算范围内元素和**的函数

```python
def areaRect(x1,y1,x2,y2):
    return P[x2][y2]-P[x1-1][y2]-P[x2][y1-1]+P[x1-1][y1-1]
```

3. 进行循环遍历处理，这里可以形成自己的思维。

   因为二维前缀和数组的**维度**比原数组大**①**，所以容易产生混淆：

   - 在遍历数组的时候，我们都使用**在原来数组**中的坐标
   - 如果涉及到边长，我们使用真实边长；注意新的位置**有时需要减一**`i+r-1`
   - 传入二维前缀和数组的时候，再把每一个位置都加上**①**

```python
# 1314 矩阵和
# i - K <= r <= i + K, j - K <= c <= j + K
for i in range(m):
    for j in range(n):
        right_x=i+K if i+K<m else m-1
        right_y=j+K if j+K<n else n-1
        left_x=i-K if i-K>=0 else 0
        left_y=j-K if j-K>=0 else 0
        #左侧+1就从1开始了，这样还对吗？
        #还是正确的，这样的思路更容易想到
        #找到原来的位置，然后+1修改成我们的增广矩阵的位置
        mat[i][j]=areaRect(left_x+1,left_y+1,right_x+1,right_y+1)
```

```python
# 1292 正方形区域的最大边长
maxR,r=min(m,n),0
for i in range(m):
    for j in range(n):
        for c in range(r+1,maxR+1):
            #还是使用原来矩阵和新矩阵的映射
            #在传入函数中计算之前都是原来矩阵
            if i+c-1<m and j+c-1<n and areaRect(i+1,j+1,i+c,j+c)<=threshold:
                r+=1
                else:
                    break
```

### 相关习题

[1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/)

[1314. 矩阵区域和](https://leetcode-cn.com/problems/matrix-block-sum/)