<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>队列和栈</title></head>
<body><h1>数据结构：队列和栈</h1>
<h1>队列</h1>
<h3>设计循环队列</h3>
<pre><code class='language-python' lang='python'>class MyCircularQueue:

    def __init__(self, k: int):
        &quot;&quot;&quot;
        Initialize your data structure here. Set the size of the queue to be k.
        &quot;&quot;&quot;
        self.queue = [0]*k
        self.headIndex = 0
        self.count = 0
        self.capacity = k

    def enQueue(self, value: int) -&gt; bool:
        &quot;&quot;&quot;
        Insert an element into the circular queue. Return true if the operation is successful.
        &quot;&quot;&quot;
        if self.count == self.capacity:
            return False
        self.queue[(self.headIndex + self.count) % self.capacity] = value
        self.count += 1
        return True

    def deQueue(self) -&gt; bool:
        &quot;&quot;&quot;
        Delete an element from the circular queue. Return true if the operation is successful.
        &quot;&quot;&quot;
        if self.count == 0:
            return False
        self.headIndex = (self.headIndex + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -&gt; int:
        &quot;&quot;&quot;
        Get the front item from the queue.
        &quot;&quot;&quot;
        if self.count == 0:
            return -1
        return self.queue[self.headIndex]

    def Rear(self) -&gt; int:
        &quot;&quot;&quot;
        Get the last item from the queue.
        &quot;&quot;&quot;
        # empty queue
        if self.count == 0:
            return -1
        return self.queue[(self.headIndex + self.count - 1) % self.capacity]

    def isEmpty(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks whether the circular queue is empty or not.
        &quot;&quot;&quot;
        return self.count == 0

    def isFull(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks whether the circular queue is full or not.
        &quot;&quot;&quot;
        return self.count == self.capacity
</code></pre>
<h3>数据流中的移动平均值</h3>
<pre><code class='language-python' lang='python'>class MovingAverage:

    def __init__(self, size: int):
        self.maxSize=size
        self.window=[]
        

    def next(self, val: int) -&gt; float:
        if len(self.window)==self.maxSize:
            self.window.pop(0)
        self.window.append(val)
        return sum(self.window)/len(self.window)
</code></pre>
<p>&nbsp;</p>
<h2>BFS</h2>
<p>广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。</p>
<p><strong>BFS模板</strong>：通常使用队列 + 不重复元素的<code>hashmap</code>或者<code>visited</code></p>
<pre><code class='language-python' lang='python'>def BFS(root, target):
    if not root:return xx
    queue=collections.deque()
    visited = [[False for i in range(n)] for j in range(m)]
    
    step=0
    queue.append(root)
    
    while queue:
        step+=1
        size=len(queue)
        for i in range(size):
            curr=queue.popleft()
            visited[curr]=True
            if curr==target:return step
            for next in neibours:
                if next not in visited:
                    queue.append(next)
                   	vivisted[next]=True
            
</code></pre>
<p>两种情况不需要使用<code>visited</code>：</p>
<ul>
<li>树：确定没有循环</li>
<li>希望多次访问同一个节点</li>

</ul>
<h3>岛屿数量：基础BFS</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        if not grid or not grid[0]:return 0
        m,n=len(grid),len(grid[0])
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def bfs(r,c):
            queue=collections.deque()
            queue.append((r,c))
            while queue:
                size=len(queue)
                for _ in range(size):
                    currR,currC=queue.popleft()
                    if currR&lt;0 or currR&gt;=m or currC&lt;0 or currC&gt;=n:continue
                    if grid[currR][currC]==&#39;0&#39;:continue
                    grid[currR][currC]=&#39;0&#39;
                    for d in directions:
                        queue.append((currR+d[0],currC+d[1]))
        
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==&#39;1&#39;:
                    count+=1
                    bfs(i,j)
        return count
                
</code></pre>
<h3>打开转盘锁：字符串处理邻居</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def openLock(self, deadends: List[str], target: str) -&gt; int:
        def neibours_process(curr):
            result=[]
            for i in range(4):
                result.append(curr[:i]+str((int(curr[i])+1)%10)+curr[i+1:])
                result.append(curr[:i]+str((int(curr[i])-1)%10)+curr[i+1:])
            return result
        
        def bfs(root,target):
            queue=collections.deque()
            queue.append(root)
            visited=set()
            step=0
            
            while queue:
                size=len(queue)
                for _ in range(size):
                    curr=queue.popleft()
                    if curr in visited:continue
                    if curr in deadends:continue
                    if curr==target:return step
                    visited.add(curr)
                    neibours=neibours_process(curr)
                    for next in neibours:
                        queue.append(next)
                step+=1
        
        result=bfs(&quot;0000&quot;,target)
        return result if isinstance(result,int) else -1
</code></pre>
<h3>完全平方数：简单剪枝</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def numSquares(self, n: int) -&gt; int:
        if n==1:return 1
        def bfs(n):
            queue=collections.deque()
            queue.append(n)
            count=0
            
            while queue:
                size=len(queue)
                for _ in range(size):
                    number=queue.popleft()
                    temp=int(sqrt(number))
                    if number==temp**2:return count+1
                    for i in range(temp,0,-1):
                        queue.append(number-i**2)
                        
                count+=1
        count=bfs(n)
        return count if isinstance(count,int) else -1
</code></pre>
<h3>墙与门：多源点同步BFS</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        if not rooms or not rooms[0]:return rooms
        m,n=len(rooms),len(rooms[0])
        queue=collections.deque()
        visited=[[False for i in range(n)]for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        step=0
            
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    queue.append((i,j))
                    
        while queue:
            size=len(queue)
            for _ in range(size):
                currR,currC=queue.popleft()
                if currR&lt;0 or currR&gt;=m or currC&lt;0 or currC&gt;=n:continue
                if visited[currR][currC]:continue                    
                if rooms[currR][currC]==-1:continue
                if rooms[currR][currC]&gt;step:rooms[currR][currC]=step
                visited[currR][currC]=True

                for d in directions:
                    queue.append((currR+d[0],currC+d[1]))
            step+=1  
                
        return rooms
</code></pre>
<hr />
<h2>BFS小结</h2>
<ol start='' >
<li><p>Python的队列</p>
<pre><code class='language-python' lang='python'>queue=collections.deque()

queue.append(element)
queue.popleft()

size=len(queue)
</code></pre>
</li>
<li><p>整体来看 <code>BFS</code> 算法思想就是层次遍历</p>
</li>
<li><p>注意是否需要<code>visited</code> 和 如何生成 <code>neighbors</code></p>
</li>

</ol>
<hr />
<h1>栈</h1>
<p>对于我们常用的 <code>Python</code> 我们使用 <code>stack=[]</code> 就可以了。</p>
<h3>最小栈</h3>
<pre><code class='language-python' lang='python'>class MinStack:

    def __init__(self):
        self.min=sys.maxsize
        self.stack=[]

    def push(self, x: int) -&gt; None:
        self.stack.append(x-self.min)
        if x&lt;self.min:
            self.min=x
            
    def pop(self) -&gt; None:
        target=self.stack.pop()
        if target&lt;0:
            self.min=self.min-target
        
    def top(self) -&gt; int:
        if self.stack:
            target=self.stack[-1]
            if target&lt;0:return self.min
            return target+self.min

    def getMin(self) -&gt; int:
        return self.min
</code></pre>
<h3>有效的括号</h3>
<p>注意无效情况的快速判断 - 剪枝</p>
<pre><code class='language-python' lang='python'>class Solution:
    def isValid(self, s: str) -&gt; bool:
        stack=[]
        pairs={&#39;(&#39;:&#39;)&#39;,&#39;[&#39;:&#39;]&#39;,&#39;{&#39;:&#39;}&#39;}
        for char in s:
            if char in pairs:
                stack.append(char)
            else:
                if len(stack)==0:return False
                if pairs[stack[-1]]!=char:return False
                else:stack.pop()
        return len(stack)==0
</code></pre>
<h3>每日温度</h3>
<p>栈里面存储的是递减的元素 - 栈题型中：里面存储元素的特异性</p>
<pre><code class='language-python' lang='python'>class Solution:
    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:
        if not T:return 0
        length=len(T)
        
        stack=[]
        result=[0 for _ in range(length)]
        
        for idx,temp in enumerate(T):
            if len(stack)==0:
                stack.append(idx)
                continue
            if temp&lt;=T[stack[-1]]:
                stack.append(idx)
                continue
            while stack and temp&gt;T[stack[-1]]:
                result[stack[-1]]=idx-stack[-1]
                stack.pop()
            stack.append(idx)
            
        return result
</code></pre>
<h3>逆波兰表达式求值</h3>
<p>注意 <code>Python除法</code> 的细节，<code>-6//12=-1</code>，所以最后使用了 <code>int(op1/op2)</code></p>
<pre><code class='language-python' lang='python'>class Solution:
    def evalRPN(self, tokens: List[str]) -&gt; int:
        stack=[]
        operations=[&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;]
        for element in tokens:
            if element in operations:
                op2=stack.pop()
                op1=stack.pop()
                if element==&#39;+&#39;:stack.append(op1+op2)
                elif element==&#39;-&#39;:stack.append(op1-op2)
                elif element==&#39;*&#39;:stack.append(op1*op2)
                elif element==&#39;/&#39;:stack.append(int(op1/op2))
            else:
                stack.append(int(element))
        
        return stack[-1]
</code></pre>
<h2>DFS</h2>
<p>在我们到达<code>最深的</code>结点之后，我们<code>只</code>会回溯并尝试另一条路径。</p>
<h3>DFS模板 I</h3>
<p>这个模板是我最开始写题目时候最顺手的一个模板：</p>
<ul>
<li><p>代码简洁易懂，对节点的判断在进入函数之后</p>
</li>
<li><p>同时也可以产生出新的版本：</p>
<ul>
<li>在进入递归之前首先对于节点的有效性进行判断</li>
<li>对于递归的出口仍然保留在进入递归之后，不僭越进行判断</li>
<li>这样减少不必要的函数调用，同时能够使得递归形式更加简洁</li>

</ul>
</li>

</ul>
<pre><code class='language-python' lang='python'>visited=[[False for i in range(m)] for j in range(n)]

def dfs(curr,target):
    if curr is invalid or curr is visited:return
    if curr==target:result.append(curr)
    
    visited[curr]=True
    #对当前节点其他操作
    Some_operation()
    for next in neibours:
        dfs(next,target)
    #如果回溯
    #visited[curr]=False   
</code></pre>
<p>判断版本：主要是担心判断的时候不充分，或者判断太复杂</p>
<pre><code class='language-python' lang='python'>visited=[[False for i in range(m)] for j in range(n)]

def dfs(curr,target):
    if curr==target:result.append(curr)
    
    visited[curr]=True
    #对当前节点其他操作
    Some_operation()
    for next in neibours:
        if next is valid and next is not visited:
        	dfs(next,target)
    #如果回溯
    #visited[curr]=False   
</code></pre>
<p>&nbsp;</p>
<h3>岛屿数量</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        if not grid or not grid[0]:return 0
        m,n=len(grid),len(grid[0])
        
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            if r&lt;0 or r&gt;=m or c&lt;0 or c&gt;=n or grid[r][c]==&#39;0&#39; :return 
            grid[r][c]=&#39;0&#39;
            for d in directions:
                dfs(r+d[0],c+d[1])
                
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==&#39;1&#39;:
                    count+=1
                    dfs(i,j)
        return count
</code></pre>
<h3>克隆图</h3>
<p>克隆问题都可以是类似的思路。</p>
<pre><code class='language-python' lang='python'>class Solution:
    def __init__(self):
        self.visited={}
        
    def cloneGraph(self, node: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        
        if not node:return node
        if node in self.visited:return self.visited[node]
        clone_node=Node(node.val,[])
        self.visited[node]=clone_node        
        if node.neighbors:
            clone_node.neighbors=[self.cloneGraph(i) for i in node.neighbors]
        return clone_node
</code></pre>
<h3>目标和</h3>
<p>展示两种方法：</p>
<ol start='' >
<li><p>纯正的DFS但是超时了，可能大量重复计算了</p>
<pre><code class='language-python' lang='python'>class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -&gt; int:
        if not nums:return 0
        self.count,self.length=0,len(nums)
        
        def dfs(curr,bit):
            if curr==0 and bit==self.length:
                self.count+=1
                return
            if bit==self.length:return
            dfs(curr+nums[bit],bit+1)
            dfs(curr-nums[bit],bit+1)
        
        dfs(-S,0)
        return self.count
</code></pre>
</li>
<li><p>DFS要学会 <code>类似树状展开</code> 的计算方式</p>
<pre><code class='language-python' lang='python'>class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -&gt; int:
        if not nums:return 0
        self.visited,self.length={},len(nums)
        def dfs(curr,i):
            if i&lt;self.length and (curr,i) not in self.visited:
                self.visited[(curr,i)]=dfs(curr+nums[i],i+1)+dfs(curr-nums[i],i+1)
            return self.visited.get((curr,i),int(curr==S))
        return dfs(0,0)
</code></pre>
</li>

</ol>
<h3>DFS模板 II</h3>
<p>避免递归深度太高，堆栈溢出 -&gt; 使用BFS，或者显式栈实现DFS</p>
<pre><code class='language-python' lang='python'>def DFS(root,target):
    visited=set()
    stack=[root]
    while stack:
        curr=stack[-1]
        if curr==target:return True
        for next in neibours:
            if next is not in visited:
                stack.append(next)
                visited.add(next)
        remove curr from stack
    return False
</code></pre>
<h3>中序遍历</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        if not root:return []
        result,stack=[],[(root,0)]
        while stack:
            node,times=stack.pop()
            if not node:continue
            if times==1:
                result.append(node.val)
                stack.append((node.right,0))
                continue
            stack.append((node,1))
            stack.append((node.left,0))
        return result
</code></pre>
<hr />
<h1>总结</h1>
<h3>用栈实现队列</h3>
<p>直白地使用 <code>helpStack</code></p>
<pre><code class='language-python' lang='python'>class MyQueue:

    def __init__(self):
        self.stack=[]
        self.helpStack=[]

    def push(self, x: int) -&gt; None:
        self.stack.append(x)

    def pop(self) -&gt; int:
        if self.helpStack:return self.helpStack.pop()
        while self.stack:
            self.helpStack.append(self.stack.pop())
        return self.helpStack.pop()

    def peek(self) -&gt; int:
        if self.helpStack:return self.helpStack[-1]
        while self.stack:
            self.helpStack.append(self.stack.pop())
        return self.helpStack[-1]

    def empty(self) -&gt; bool:
        return not self.stack and not self.helpStack
</code></pre>
<h3>用队列实现栈</h3>
<pre><code class='language-python' lang='python'>class MyStack:

    def __init__(self):
        self.queue=collections.deque()

    def push(self, x: int) -&gt; None:
        size=len(self.queue)
        self.queue.append(x)
        for _ in range(size):
            self.queue.append(self.queue.popleft())

    def pop(self) -&gt; int:
        return self.queue.popleft()

    def top(self) -&gt; int:
        return self.queue[0]
        
    def empty(self) -&gt; bool:
        return len(self.queue)==0
</code></pre>
<h3>字符串解码</h3>
<p>类似栈的处理 - 一步一步写下来并不难，需要注意数字代表的次数重叠的情况</p>
<p>测试用例： <code>&quot;3[z]2[2[y]pq4[2[jk]e1[f]]]ef&quot;</code></p>
<pre><code class='language-python' lang='python'>class Solution:
    def decodeString(self, s: str) -&gt; str:
        stack,result,=[],&quot;&quot;
        for char in s:
            if &#39;0&#39;&lt;=char&lt;=&#39;9&#39;:
                stack.append(char)
            elif char==&#39;[&#39;:
                stack.append(&#39;[&#39;)
            elif char==&#39;]&#39;:
                temp,times=&quot;&quot;,&quot;&quot;
                while stack and stack[-1]!=&#39;[&#39;:
                    temp=stack.pop()+temp
                stack.pop()
                while stack and &#39;0&#39;&lt;=stack[-1]&lt;=&#39;9&#39;:
                    times=stack.pop()+times
                temp=temp*int(times)
                for i in range(len(temp)):
                    stack.append(temp[i])
            else:
                if not stack:
                    result+=char
                    continue
                stack.append(char)
            #print(char,result,stack)
        return result+&#39;&#39;.join(stack)
</code></pre>
<h3>图像渲染</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:
        if not image or not image[0]:return image
        rawColor=image[sr][sc]
        if rawColor==newColor:return image
        
        m,n=len(image),len(image[0])  
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            if r&lt;0 or r&gt;=m or c&lt;0 or c&gt;=n or visited[r][c] or image[r][c]!=rawColor:return
            visited[r][c]=True
            image[r][c]=newColor
            for d in directions:
                dfs(r+d[0],c+d[1])
        
        dfs(sr,sc)
        return image
</code></pre>
<p>这个再写一个版本看看【版本的区别主要是递归前是否先判断可行性】</p>
<pre><code class='language-python' lang='python'>class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:
        if not image or not image[0]:return image
        rawColor=image[sr][sc]
        if rawColor==newColor:return image
        
        m,n=len(image),len(image[0])  
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            visited[r][c]=True
            image[r][c]=newColor
            for d in directions:
                newR,newC=r+d[0],c+d[1]
                if 0&lt;=newR&lt;m and 0&lt;=newC&lt;n and not visited[newR][newC] and image[newR][newC]==rawColor:
                    dfs(newR,newC)
        
        dfs(sr,sc)
        return image
</code></pre>
<h3>01矩阵</h3>
<p>多源BFS模板，注意添加进元素的时候避免重复：</p>
<ul>
<li><p>扫描向队列添加源点的时候，就设置<code>visited[i][j]=True</code></p>
</li>
<li><p>访问的时候，只对可行的元素继续搜索</p>
</li>
<li><p>添加元素进队列的时候，同步设置<code>visited[i][j]=True</code></p>
<ul>
<li>为了避免重复添加相同元素：就是需要添加的时候同步设置已经访问过</li>
<li>如果像之前那样等下一层再去设置，就晚了（有可能已经添加过了）</li>

</ul>
</li>

</ul>
<pre><code class='language-python' lang='python'>class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -&gt; List[List[int]]:
        if not matrix or not matrix[0]:return matrix
        
        m,n=len(matrix),len(matrix[0])
        queue=collections.deque()
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        step=0
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j]==0:
                    queue.append((i,j))
                    visited[i][j]=True
                    
        while queue:
            size=len(queue)
            for _ in range(size):
                currR,currC=queue.popleft()
                matrix[currR][currC]=step
                for d in directions:
                    nextR,nextC=currR+d[0],currC+d[1]
                    if 0&lt;=nextR&lt;m and 0&lt;=nextC&lt;n and not visited[nextR][nextC] and matrix[nextR][nextC]!=0:       
                        queue.append((nextR,nextC))
                        visited[nextR][nextC]=True
            step+=1
            
        return matrix
</code></pre>
<h3>钥匙和房间</h3>
<pre><code class='language-python' lang='python'>class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -&gt; bool:
        length=len(rooms)
        queue=collections.deque()
        visited=[False for i in range(length)]
        queue.append(0)
        visited[0]=True
        
        while queue:
            size=len(queue)
            for _ in range(size):
                keys=rooms[queue.popleft()]
                for key in keys:
                    if not visited[key]:
                        visited[key]=True
                        queue.append(key)
                
        return sum(visited)==length
</code></pre>
<p>&nbsp;</p>
</body>
</html>