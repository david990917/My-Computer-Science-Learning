# 队列和栈总结

### 用栈实现队列

直白地使用 `helpStack`

```python
class MyQueue:

    def __init__(self):
        self.stack=[]
        self.helpStack=[]

    def push(self, x: int) -> None:
        self.stack.append(x)

    def pop(self) -> int:
        if self.helpStack:return self.helpStack.pop()
        while self.stack:
            self.helpStack.append(self.stack.pop())
        return self.helpStack.pop()

    def peek(self) -> int:
        if self.helpStack:return self.helpStack[-1]
        while self.stack:
            self.helpStack.append(self.stack.pop())
        return self.helpStack[-1]

    def empty(self) -> bool:
        return not self.stack and not self.helpStack
```

### 用队列实现栈

```python
class MyStack:

    def __init__(self):
        self.queue=collections.deque()

    def push(self, x: int) -> None:
        size=len(self.queue)
        self.queue.append(x)
        for _ in range(size):
            self.queue.append(self.queue.popleft())

    def pop(self) -> int:
        return self.queue.popleft()

    def top(self) -> int:
        return self.queue[0]
        
    def empty(self) -> bool:
        return len(self.queue)==0
```

### 字符串解码

类似栈的处理 - 一步一步写下来并不难，需要注意数字代表的次数重叠的情况

测试用例： `"3[z]2[2[y]pq4[2[jk]e1[f]]]ef"`

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack,result,=[],""
        for char in s:
            if '0'<=char<='9':
                stack.append(char)
            elif char=='[':
                stack.append('[')
            elif char==']':
                temp,times="",""
                while stack and stack[-1]!='[':
                    temp=stack.pop()+temp
                stack.pop()
                while stack and '0'<=stack[-1]<='9':
                    times=stack.pop()+times
                temp=temp*int(times)
                for i in range(len(temp)):
                    stack.append(temp[i])
            else:
                if not stack:
                    result+=char
                    continue
                stack.append(char)
            #print(char,result,stack)
        return result+''.join(stack)
```

### 图像渲染

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if not image or not image[0]:return image
        rawColor=image[sr][sc]
        if rawColor==newColor:return image
        
        m,n=len(image),len(image[0])  
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            if r<0 or r>=m or c<0 or c>=n or visited[r][c] or image[r][c]!=rawColor:return
            visited[r][c]=True
            image[r][c]=newColor
            for d in directions:
                dfs(r+d[0],c+d[1])
        
        dfs(sr,sc)
        return image
```

这个再写一个版本看看【版本的区别主要是递归前是否先判断可行性】

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if not image or not image[0]:return image
        rawColor=image[sr][sc]
        if rawColor==newColor:return image
        
        m,n=len(image),len(image[0])  
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            visited[r][c]=True
            image[r][c]=newColor
            for d in directions:
                newR,newC=r+d[0],c+d[1]
                if 0<=newR<m and 0<=newC<n and not visited[newR][newC] and image[newR][newC]==rawColor:
                    dfs(newR,newC)
        
        dfs(sr,sc)
        return image
```

### 01矩阵

多源BFS模板，注意添加进元素的时候避免重复：

- 扫描向队列添加源点的时候，就设置`visited[i][j]=True`
- 访问的时候，只对可行的元素继续搜索
- 添加元素进队列的时候，同步设置`visited[i][j]=True`
  - 为了避免重复添加相同元素：就是需要添加的时候同步设置已经访问过
  - 如果像之前那样等下一层再去设置，就晚了（有可能已经添加过了）

```python
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix or not matrix[0]:return matrix
        
        m,n=len(matrix),len(matrix[0])
        queue=collections.deque()
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        step=0
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j]==0:
                    queue.append((i,j))
                    visited[i][j]=True
                    
        while queue:
            size=len(queue)
            for _ in range(size):
                currR,currC=queue.popleft()
                matrix[currR][currC]=step
                for d in directions:
                    nextR,nextC=currR+d[0],currC+d[1]
                    if 0<=nextR<m and 0<=nextC<n and not visited[nextR][nextC] and matrix[nextR][nextC]!=0:       
                        queue.append((nextR,nextC))
                        visited[nextR][nextC]=True
            step+=1
            
        return matrix
```

### 钥匙和房间

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        length=len(rooms)
        queue=collections.deque()
        visited=[False for i in range(length)]
        queue.append(0)
        visited[0]=True
        
        while queue:
            size=len(queue)
            for _ in range(size):
                keys=rooms[queue.popleft()]
                for key in keys:
                    if not visited[key]:
                        visited[key]=True
                        queue.append(key)
                
        return sum(visited)==length
```

