# 数据结构：队列和栈

# 队列

### 设计循环队列

```python
class MyCircularQueue:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        """
        self.queue = [0]*k
        self.headIndex = 0
        self.count = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        """
        if self.count == self.capacity:
            return False
        self.queue[(self.headIndex + self.count) % self.capacity] = value
        self.count += 1
        return True

    def deQueue(self) -> bool:
        """
        Delete an element from the circular queue. Return true if the operation is successful.
        """
        if self.count == 0:
            return False
        self.headIndex = (self.headIndex + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -> int:
        """
        Get the front item from the queue.
        """
        if self.count == 0:
            return -1
        return self.queue[self.headIndex]

    def Rear(self) -> int:
        """
        Get the last item from the queue.
        """
        # empty queue
        if self.count == 0:
            return -1
        return self.queue[(self.headIndex + self.count - 1) % self.capacity]

    def isEmpty(self) -> bool:
        """
        Checks whether the circular queue is empty or not.
        """
        return self.count == 0

    def isFull(self) -> bool:
        """
        Checks whether the circular queue is full or not.
        """
        return self.count == self.capacity
```

### 数据流中的移动平均值

```python
class MovingAverage:

    def __init__(self, size: int):
        self.maxSize=size
        self.window=[]
        

    def next(self, val: int) -> float:
        if len(self.window)==self.maxSize:
            self.window.pop(0)
        self.window.append(val)
        return sum(self.window)/len(self.window)
```



## BFS

广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。

**BFS模板**：通常使用队列 + 不重复元素的`hashmap`或者`visited`

```python
def BFS(root, target):
    if not root:return xx
    queue=collections.deque()
    visited = [[False for i in range(n)] for j in range(m)]
    
    step=0
    queue.append(root)
    
    while queue:
        step+=1
        size=len(queue)
        for i in range(size):
            curr=queue.popleft()
            visited[curr]=True
            if curr==target:return step
            for next in neibours:
                if next not in visited:
                    queue.append(next)
                   	vivisted[next]=True
            
```

两种情况不需要使用`visited`：

- 树：确定没有循环
- 希望多次访问同一个节点

### 岛屿数量：基础BFS

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:return 0
        m,n=len(grid),len(grid[0])
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def bfs(r,c):
            queue=collections.deque()
            queue.append((r,c))
            while queue:
                size=len(queue)
                for _ in range(size):
                    currR,currC=queue.popleft()
                    if currR<0 or currR>=m or currC<0 or currC>=n:continue
                    if grid[currR][currC]=='0':continue
                    grid[currR][currC]='0'
                    for d in directions:
                        queue.append((currR+d[0],currC+d[1]))
        
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]=='1':
                    count+=1
                    bfs(i,j)
        return count
                
```

### 打开转盘锁：字符串处理邻居

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        def neibours_process(curr):
            result=[]
            for i in range(4):
                result.append(curr[:i]+str((int(curr[i])+1)%10)+curr[i+1:])
                result.append(curr[:i]+str((int(curr[i])-1)%10)+curr[i+1:])
            return result
        
        def bfs(root,target):
            queue=collections.deque()
            queue.append(root)
            visited=set()
            step=0
            
            while queue:
                size=len(queue)
                for _ in range(size):
                    curr=queue.popleft()
                    if curr in visited:continue
                    if curr in deadends:continue
                    if curr==target:return step
                    visited.add(curr)
                    neibours=neibours_process(curr)
                    for next in neibours:
                        queue.append(next)
                step+=1
        
        result=bfs("0000",target)
        return result if isinstance(result,int) else -1
```

### 完全平方数：简单剪枝

```python
class Solution:
    def numSquares(self, n: int) -> int:
        if n==1:return 1
        def bfs(n):
            queue=collections.deque()
            queue.append(n)
            count=0
            
            while queue:
                size=len(queue)
                for _ in range(size):
                    number=queue.popleft()
                    temp=int(sqrt(number))
                    if number==temp**2:return count+1
                    for i in range(temp,0,-1):
                        queue.append(number-i**2)
                        
                count+=1
        count=bfs(n)
        return count if isinstance(count,int) else -1
```

### 墙与门：多源点同步BFS

```python
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        if not rooms or not rooms[0]:return rooms
        m,n=len(rooms),len(rooms[0])
        queue=collections.deque()
        visited=[[False for i in range(n)]for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        step=0
            
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    queue.append((i,j))
                    
        while queue:
            size=len(queue)
            for _ in range(size):
                currR,currC=queue.popleft()
                if currR<0 or currR>=m or currC<0 or currC>=n:continue
                if visited[currR][currC]:continue                    
                if rooms[currR][currC]==-1:continue
                if rooms[currR][currC]>step:rooms[currR][currC]=step
                visited[currR][currC]=True

                for d in directions:
                    queue.append((currR+d[0],currC+d[1]))
            step+=1  
                
        return rooms
```

---

## BFS小结

1. Python的队列

   ```python
   queue=collections.deque()
   
   queue.append(element)
   queue.popleft()
   
   size=len(queue)
   ```

2. 整体来看 `BFS` 算法思想就是层次遍历

3. 注意是否需要`visited` 和 如何生成 `neighbors`

---

# 栈

对于我们常用的 `Python` 我们使用 `stack=[]` 就可以了。

### 最小栈

```python
class MinStack:

    def __init__(self):
        self.min=sys.maxsize
        self.stack=[]

    def push(self, x: int) -> None:
        self.stack.append(x-self.min)
        if x<self.min:
            self.min=x
            
    def pop(self) -> None:
        target=self.stack.pop()
        if target<0:
            self.min=self.min-target
        
    def top(self) -> int:
        if self.stack:
            target=self.stack[-1]
            if target<0:return self.min
            return target+self.min

    def getMin(self) -> int:
        return self.min
```

### 有效的括号

注意无效情况的快速判断 - 剪枝

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        pairs={'(':')','[':']','{':'}'}
        for char in s:
            if char in pairs:
                stack.append(char)
            else:
                if len(stack)==0:return False
                if pairs[stack[-1]]!=char:return False
                else:stack.pop()
        return len(stack)==0
```

### 每日温度

栈里面存储的是递减的元素 - 栈题型中：里面存储元素的特异性

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        if not T:return 0
        length=len(T)
        
        stack=[]
        result=[0 for _ in range(length)]
        
        for idx,temp in enumerate(T):
            if len(stack)==0:
                stack.append(idx)
                continue
            if temp<=T[stack[-1]]:
                stack.append(idx)
                continue
            while stack and temp>T[stack[-1]]:
                result[stack[-1]]=idx-stack[-1]
                stack.pop()
            stack.append(idx)
            
        return result
```

### 逆波兰表达式求值

注意 `Python除法` 的细节，`-6//12=-1`，所以最后使用了 `int(op1/op2)`

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack=[]
        operations=['+','-','*','/']
        for element in tokens:
            if element in operations:
                op2=stack.pop()
                op1=stack.pop()
                if element=='+':stack.append(op1+op2)
                elif element=='-':stack.append(op1-op2)
                elif element=='*':stack.append(op1*op2)
                elif element=='/':stack.append(int(op1/op2))
            else:
                stack.append(int(element))
        
        return stack[-1]
```

## DFS

在我们到达`最深的`结点之后，我们`只`会回溯并尝试另一条路径。

### DFS模板 I

这个模板是我最开始写题目时候最顺手的一个模板：

- 代码简洁易懂，对节点的判断在进入函数之后
- 同时也可以产生出新的版本：
  - 在进入递归之前首先对于节点的有效性进行判断
  - 对于递归的出口仍然保留在进入递归之后，不僭越进行判断
  - 这样减少不必要的函数调用，同时能够使得递归形式更加简洁

```python
visited=[[False for i in range(m)] for j in range(n)]

def dfs(curr,target):
    if curr is invalid or curr is visited:return
    if curr==target:result.append(curr)
    
    visited[curr]=True
    #对当前节点其他操作
    Some_operation()
    for next in neibours:
        dfs(next,target)
    #如果回溯
    #visited[curr]=False   
```

判断版本：主要是担心判断的时候不充分，或者判断太复杂

```python
visited=[[False for i in range(m)] for j in range(n)]

def dfs(curr,target):
    if curr==target:result.append(curr)
    
    visited[curr]=True
    #对当前节点其他操作
    Some_operation()
    for next in neibours:
        if next is valid and next is not visited:
        	dfs(next,target)
    #如果回溯
    #visited[curr]=False   
```



### 岛屿数量

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:return 0
        m,n=len(grid),len(grid[0])
        
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            if r<0 or r>=m or c<0 or c>=n or grid[r][c]=='0' :return 
            grid[r][c]='0'
            for d in directions:
                dfs(r+d[0],c+d[1])
                
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]=='1':
                    count+=1
                    dfs(i,j)
        return count
```

### 克隆图

克隆问题都可以是类似的思路。

```python
class Solution:
    def __init__(self):
        self.visited={}
        
    def cloneGraph(self, node: 'Node') -> 'Node':
        
        if not node:return node
        if node in self.visited:return self.visited[node]
        clone_node=Node(node.val,[])
        self.visited[node]=clone_node        
        if node.neighbors:
            clone_node.neighbors=[self.cloneGraph(i) for i in node.neighbors]
        return clone_node
```

### 目标和

展示两种方法：

1. 纯正的DFS但是超时了，可能大量重复计算了

   ```python
   class Solution:
       def findTargetSumWays(self, nums: List[int], S: int) -> int:
           if not nums:return 0
           self.count,self.length=0,len(nums)
           
           def dfs(curr,bit):
               if curr==0 and bit==self.length:
                   self.count+=1
                   return
               if bit==self.length:return
               dfs(curr+nums[bit],bit+1)
               dfs(curr-nums[bit],bit+1)
           
           dfs(-S,0)
           return self.count
   ```

2. DFS要学会 `类似树状展开` 的计算方式

   ```python
   class Solution:
       def findTargetSumWays(self, nums: List[int], S: int) -> int:
           if not nums:return 0
           self.visited,self.length={},len(nums)
           def dfs(curr,i):
               if i<self.length and (curr,i) not in self.visited:
                   self.visited[(curr,i)]=dfs(curr+nums[i],i+1)+dfs(curr-nums[i],i+1)
               return self.visited.get((curr,i),int(curr==S))
           return dfs(0,0)
   ```

### DFS模板 II

避免递归深度太高，堆栈溢出 -> 使用BFS，或者显式栈实现DFS

```python
def DFS(root,target):
    visited=set()
    stack=[root]
    while stack:
        curr=stack[-1]
        if curr==target:return True
        for next in neibours:
            if next is not in visited:
                stack.append(next)
                visited.add(next)
        remove curr from stack
    return False
```

### 中序遍历

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:return []
        result,stack=[],[(root,0)]
        while stack:
            node,times=stack.pop()
            if not node:continue
            if times==1:
                result.append(node.val)
                stack.append((node.right,0))
                continue
            stack.append((node,1))
            stack.append((node.left,0))
        return result
```

---

# 总结

### 用栈实现队列

直白地使用 `helpStack`

```python
class MyQueue:

    def __init__(self):
        self.stack=[]
        self.helpStack=[]

    def push(self, x: int) -> None:
        self.stack.append(x)

    def pop(self) -> int:
        if self.helpStack:return self.helpStack.pop()
        while self.stack:
            self.helpStack.append(self.stack.pop())
        return self.helpStack.pop()

    def peek(self) -> int:
        if self.helpStack:return self.helpStack[-1]
        while self.stack:
            self.helpStack.append(self.stack.pop())
        return self.helpStack[-1]

    def empty(self) -> bool:
        return not self.stack and not self.helpStack
```

### 用队列实现栈

```python
class MyStack:

    def __init__(self):
        self.queue=collections.deque()

    def push(self, x: int) -> None:
        size=len(self.queue)
        self.queue.append(x)
        for _ in range(size):
            self.queue.append(self.queue.popleft())

    def pop(self) -> int:
        return self.queue.popleft()

    def top(self) -> int:
        return self.queue[0]
        
    def empty(self) -> bool:
        return len(self.queue)==0
```

### 字符串解码

类似栈的处理 - 一步一步写下来并不难，需要注意数字代表的次数重叠的情况

测试用例： `"3[z]2[2[y]pq4[2[jk]e1[f]]]ef"`

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack,result,=[],""
        for char in s:
            if '0'<=char<='9':
                stack.append(char)
            elif char=='[':
                stack.append('[')
            elif char==']':
                temp,times="",""
                while stack and stack[-1]!='[':
                    temp=stack.pop()+temp
                stack.pop()
                while stack and '0'<=stack[-1]<='9':
                    times=stack.pop()+times
                temp=temp*int(times)
                for i in range(len(temp)):
                    stack.append(temp[i])
            else:
                if not stack:
                    result+=char
                    continue
                stack.append(char)
            #print(char,result,stack)
        return result+''.join(stack)
```

### 图像渲染

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if not image or not image[0]:return image
        rawColor=image[sr][sc]
        if rawColor==newColor:return image
        
        m,n=len(image),len(image[0])  
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            if r<0 or r>=m or c<0 or c>=n or visited[r][c] or image[r][c]!=rawColor:return
            visited[r][c]=True
            image[r][c]=newColor
            for d in directions:
                dfs(r+d[0],c+d[1])
        
        dfs(sr,sc)
        return image
```

这个再写一个版本看看【版本的区别主要是递归前是否先判断可行性】

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if not image or not image[0]:return image
        rawColor=image[sr][sc]
        if rawColor==newColor:return image
        
        m,n=len(image),len(image[0])  
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        
        def dfs(r,c):
            visited[r][c]=True
            image[r][c]=newColor
            for d in directions:
                newR,newC=r+d[0],c+d[1]
                if 0<=newR<m and 0<=newC<n and not visited[newR][newC] and image[newR][newC]==rawColor:
                    dfs(newR,newC)
        
        dfs(sr,sc)
        return image
```

### 01矩阵

多源BFS模板，注意添加进元素的时候避免重复：

- 扫描向队列添加源点的时候，就设置`visited[i][j]=True`
- 访问的时候，只对可行的元素继续搜索
- 添加元素进队列的时候，同步设置`visited[i][j]=True`
  - 为了避免重复添加相同元素：就是需要添加的时候同步设置已经访问过
  - 如果像之前那样等下一层再去设置，就晚了（有可能已经添加过了）

```python
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix or not matrix[0]:return matrix
        
        m,n=len(matrix),len(matrix[0])
        queue=collections.deque()
        visited=[[False for i in range(n)] for j in range(m)]
        directions=[(1,0),(-1,0),(0,1),(0,-1)]
        step=0
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j]==0:
                    queue.append((i,j))
                    visited[i][j]=True
                    
        while queue:
            size=len(queue)
            for _ in range(size):
                currR,currC=queue.popleft()
                matrix[currR][currC]=step
                for d in directions:
                    nextR,nextC=currR+d[0],currC+d[1]
                    if 0<=nextR<m and 0<=nextC<n and not visited[nextR][nextC] and matrix[nextR][nextC]!=0:       
                        queue.append((nextR,nextC))
                        visited[nextR][nextC]=True
            step+=1
            
        return matrix
```

### 钥匙和房间

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        length=len(rooms)
        queue=collections.deque()
        visited=[False for i in range(length)]
        queue.append(0)
        visited[0]=True
        
        while queue:
            size=len(queue)
            for _ in range(size):
                keys=rooms[queue.popleft()]
                for key in keys:
                    if not visited[key]:
                        visited[key]=True
                        queue.append(key)
                
        return sum(visited)==length
```

